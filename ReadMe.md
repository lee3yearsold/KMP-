# KMP

### 作用

KMP主要用于字符串匹配。当字符不匹配时，**可以在不查找前几个匹配字符情况下直接往后比较，从而节省了比较这前几个字符的时间**。

### 实现

KMP的精髓即next数组，通过next数组即可在不比较前几个匹配字符直接往后比较。
next数组的本质即前缀表（prefix table），

#### 前缀表构建

以aabaaf为例
1. 长度为1个字符的前缀为a，它的最长相同前后缀长度为0。（一个字符没有前后缀）
2. 长度为2个字符的前缀为aa，它的前缀为a，后缀为a，最长相同前后缀长度为1。
3. 长度为3个字符的前缀为aab，它的长度为1的前缀是a，后缀是b；长度为2的前缀为aa，后缀为ab，都不匹配，最长相同前后缀长度为0。
4. 长度为4个字符的前缀为aaba，它的长度为1的前缀是a，后缀是a；长度为2的前缀为aa，后缀为ba；长度为3的前缀为aab，后缀为aba，只有长度为1的前后缀匹配，最长相同前后缀长度为1。
5. 长度为5个字符的前缀为aabaa，它的长度为1的前缀是a，后缀是a；长度为2的前缀为aa，后缀是aa；长度为3的前缀为aab，后缀是baa；长度为4的前缀为aaba，后缀是abaa，最长相同前后缀长度为2。
6. 长度为6个字符的前缀为aabaaf，它的长度为1的前缀是a，后缀是f；长度为2的前缀为aa，后缀是af；长度为3的前缀aab，后缀是aaf；长度为4的前缀为aaba，后缀是baaf；前缀是aabaa，后缀是abaaf，最长相同前后缀长度为0。
则aabaaf的前缀表为：

| 下标 | 0 | 1 | 2 | 3 | 4 | 5 |
| -- | - | - | - | - | - | - |
|模式串 | a | a | b | a | a | f |
|前缀表 | 0 | 1 | 0 | 1 | 2 | 0 |

#### 字符串匹配

在有了前缀数组后，我们既可以在不重复匹配的情况下匹配一个字符串是否包含另一个模式串。
1. 两个字符串从头开始匹配，若字符相同，则同时向下一位迭代。
2. 当两个字符串的对应字符不同时
	1. 迭代模式串的下标更新为前缀表该下标对应数值，直至两字符串的对应字符相同或模式串下标为0。（这里的前缀表是进行有右移操作的，对应数值表示前一个前缀的最长相同前后缀长度）
	2. 若此时两字符串对应位置相同，则模式串下标向后移动一位。（字符串的下标不移动是因为在走完这一轮for循环后会自动+1）
3. 若模式串遍历完，则说明找到了。若模式串始终没有遍历完，则说明没找到。

#### 提醒

Next数组在没有右移前：Next[i]数组表示[0,i]的子串的最大相同前缀长度。
Next数组右移后：     Next[i]数组表示前[0,i-1]的子串的最大相同前缀长度，这是为了便于在该第i个字符处不相同时直接跳转到最大相同前缀长度的后一个位置直接进行后续比较。

### 代码

#### 求Next数组

```cpp
vector<int> FindNext(string neddle){
	// neddle是模式串
	vector<int> Next = vector(neddle.length(),0);
	// 第一个字符没有前后缀，所以为Next[0]为0
	int j = 0;
	Next[0] = j;
	
	// j表示的是前缀的尾部，i表示的是后缀的尾部。
	// 若neddle[j] == neddle[i]，则表示该长度前后缀相同
	// 若neddle[j] != neddle[i]，则表示该长度前后缀不相同，j要回退以找到长度更小的前缀来对比前后缀。
	for(int i = 1; i < neddle.length(); i++){
		// 如果字符不匹配，则回退到前一个
		while(j > 0 && neddle[i] != neddle[j]){
			j = next[j];
		}
		// 如果此时两个字符匹配，则表示该长度的前后缀相同。
		if(neddle[i] == neddle[j]){
			// j+1表示前后缀长度
			j++;
		}
		Next[i] = j;
	}
	
	// 此时Next数组表示的是后一个字符不匹配时要回退的位置
	// 数组进行右移以进行对应
	for(int i = neddle.length()-1; i >= 1; i--){
		Next[i] = Next[i-1];
	}
	Next[0] = -1;
	return Next;
}
```

#### 字符串匹配

```cpp
int StringCompare(string haystack, string neddle){
	// 计算Next数组
	vector<int> Next = CalNext(neddle);
	
	//字符串匹配
	for(int i = 0, j = 0; i < haystack.length(); i++){
		// 
		while(j > 0 && haystack[i] != neddle[j]){
			// 回退到上一个匹配的位置
			// 该位置前面的字符串都是匹配的
			j = Next[j];
		}
		if(haystack[i] == neddle[j]){
			// 该位置前面的字符串都匹配了
			// 若该位置的字符也相同，j右移
			j++;
		}
		if(j == neddle.length()){
			// 如果模式串匹配结束，则匹配成功，返回起始位置。
			return i - neddle.length()+1;
		}
	}
	return -1;
}
```

